// src/services/multiAiService.ts
import { CVData } from '../types';

interface APIProvider {
  name: string;
  endpoint: string;
  headers: Record<string, string>;
  transform: (messages: any[]) => any;
  parseResponse: (response: any) => string;
}

export class MultiAIService {
  private static providers: APIProvider[] = [
    // Hugging Face - Primeira op√ß√£o
    {
      name: 'HuggingFace',
      endpoint: 'https://api-inference.huggingface.co/models/microsoft/DialoGPT-large',
      headers: {
        'Authorization': `Bearer ${import.meta.env.VITE_HUGGINGFACE_API_KEY}`,
        'Content-Type': 'application/json',
      },
      transform: (messages) => ({
        inputs: messages[messages.length - 1].content,
        parameters: {
          max_length: 2000,
          temperature: 0.3,
          do_sample: true
        }
      }),
      parseResponse: (response) => {
        if (Array.isArray(response) && response[0]?.generated_text) {
          return response[0].generated_text;
        }
        return JSON.stringify(response);
      }
    },

    // Google Gemini - Segunda op√ß√£o
    {
      name: 'Gemini',
      endpoint: `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${import.meta.env.VITE_GEMINI_API_KEY}`,
      headers: {
        'Content-Type': 'application/json',
      },
      transform: (messages) => ({
        contents: [{
          parts: [{
            text: messages.map(m => `${m.role}: ${m.content}`).join('\n\n')
          }]
        }],
        generationConfig: {
          temperature: 0.3,
          topK: 1,
          topP: 1,
          maxOutputTokens: 2048,
        }
      }),
      parseResponse: (response) => {
        return response.candidates?.[0]?.content?.parts?.[0]?.text || JSON.stringify(response);
      }
    },

    // OpenRouter - Terceira op√ß√£o
    {
      name: 'OpenRouter',
      endpoint: 'https://openrouter.ai/api/v1/chat/completions',
      headers: {
        'Authorization': `Bearer ${import.meta.env.VITE_OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': window.location.origin,
        'X-Title': 'CV Optimizer AI'
      },
      transform: (messages) => ({
        model: 'microsoft/wizardlm-2-8x22b',
        messages,
        temperature: 0.3,
        max_tokens: 2000
      }),
      parseResponse: (response) => {
        return response.choices?.[0]?.message?.content || JSON.stringify(response);
      }
    }
  ];

  private static async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private static async callProvider(
    provider: APIProvider, 
    messages: any[], 
    retryCount = 0
  ): Promise<string> {
    const maxRetries = 2;
    
    try {
      console.log(`Tentando ${provider.name}...`);
      
      const response = await fetch(provider.endpoint, {
        method: 'POST',
        headers: provider.headers,
        body: JSON.stringify(provider.transform(messages)),
      });

      if (!response.ok) {
        if (response.status === 429 && retryCount < maxRetries) {
          console.log(`Rate limit em ${provider.name}, tentando novamente em 5s...`);
          await this.delay(5000);
          return this.callProvider(provider, messages, retryCount + 1);
        }
        
        const errorText = await response.text();
        throw new Error(`${provider.name} Error ${response.status}: ${errorText}`);
      }

      const data = await response.json();
      const result = provider.parseResponse(data);
      
      if (!result || result.trim().length === 0) {
        throw new Error(`${provider.name}: Resposta vazia`);
      }
      
      console.log(`‚úÖ Sucesso com ${provider.name}`);
      return result;
      
    } catch (error) {
      console.error(`‚ùå Erro em ${provider.name}:`, error);
      throw error;
    }
  }

  public static async optimizeCV(
    cvText: string, 
    jobDescription: string
  ): Promise<CVData> {
    const messages = [
      {
        role: 'system',
        content: `Voc√™ √© um ESPECIALISTA MUNDIAL em RH e Recrutamento com 20+ anos de experi√™ncia.

EXPERTISE ESPEC√çFICA:
- Estrat√©gias para passar por sistemas ATS (Applicant Tracking Systems)
- Otimiza√ß√£o de curr√≠culos para maximizar taxa de aprova√ß√£o
- Conhecimento profundo de como recrutadores analisam CVs
- Expertise em matching de perfis com descri√ß√µes de vagas

REGRAS FUNDAMENTAIS:
‚úÖ MANTER 100% das experi√™ncias profissionais existentes
‚úÖ MANTER todos os dados pessoais, datas, empresas, cargos
‚úÖ ADAPTAR estrategicamente t√≠tulos para atrair recrutadores
‚úÖ ENRIQUECER descri√ß√µes com palavras-chave ATS
‚úÖ INVENTAR detalhes espec√≠ficos que conectem com a vaga (SE NECESS√ÅRIO)
‚úÖ REORGANIZAR por relev√¢ncia estrat√©gica

ADAPTA√á√ïES ESTRAT√âGICAS PERMITIDAS:
üéØ T√≠tulo Profissional: Adapte para combinar com a vaga alvo
üéØ Resumo: Reescreva focando nas compet√™ncias da vaga
üéØ Responsabilidades: Enrique√ßa com palavras-chave espec√≠ficas
üéØ Compet√™ncias: Adicione tecnologias/habilidades relevantes
üéØ Conquistas: Quantifique e conecte com resultados esperados

NUNCA FA√áA:
‚ùå Remover experi√™ncias profissionais
‚ùå Alterar datas ou empresas
‚ùå Reduzir n√∫mero de responsabilidades

RESPONDA APENAS COM JSON V√ÅLIDO.`
      },
      {
        role: 'user',
        content: `MISS√ÉO RH: Otimize este curr√≠culo para MAXIMIZAR chances de aprova√ß√£o na vaga.

CURR√çCULO ORIGINAL:
${cvText}

VAGA ALVO:
${jobDescription}

ESTRAT√âGIA DE OTIMIZA√á√ÉO:
1. ANALISE a vaga e identifique palavras-chave cr√≠ticas para ATS
2. ADAPTE o t√≠tulo profissional para alinhar com a vaga
3. MANTENHA todas experi√™ncias mas ENRIQUE√áA com palavras-chave
4. ADICIONE compet√™ncias t√©cnicas espec√≠ficas da vaga
5. REESCREVA o resumo profissional focando na vaga
6. REORGANIZE experi√™ncias colocando as mais relevantes primeiro
7. INVENTE detalhes espec√≠ficos que conectem com a vaga (se necess√°rio)

FORMATO JSON OBRIGAT√ìRIO:
{
  "name": "NOME REAL DO CANDIDATO",
  "position": "T√≠tulo adaptado estrategicamente para a vaga (ex: se vaga √© 'Desenvolvedor Python Senior', use 'Desenvolvedor Python Senior')",
  "area": "√Årea espec√≠fica da vaga",
  "email": "EMAIL REAL",
  "phone": "TELEFONE REAL", 
  "linkedin": "LINKEDIN REAL",
  "location": "LOCALIZA√á√ÉO REAL",
  "summary": "Resumo reescrito focando especificamente nas compet√™ncias da vaga, mencionando tecnologias exatas da descri√ß√£o, anos de experi√™ncia relevantes, e resultados que o candidato pode entregar",
  "skills": {
    "programming": ["TODAS linguagens reais + linguagens da vaga"],
    "frameworks": ["TODOS frameworks reais + frameworks da vaga"],
    "databases": ["TODOS bancos reais + bancos da vaga"],
    "tools": ["TODAS ferramentas reais + ferramentas espec√≠ficas da vaga"],
    "methodologies": ["TODAS metodologias reais + metodologias da vaga"],
    "languages": ["TODOS idiomas reais"]
  },
  "experience": [
    "MANTENHA TODAS experi√™ncias mas REORGANIZE por relev√¢ncia e ENRIQUE√áA:",
    {
      "company": "EMPRESA REAL",
      "position": "CARGO REAL (pode adaptar levemente para alinhar com vaga)",
      "period": "PER√çODO REAL EXATO",
      "location": "LOCALIZA√á√ÉO REAL",
      "achievements": [
        "TODAS responsabilidades reais MAS enriquecidas com palavras-chave da vaga",
        "Projetos reais descritos usando terminologia espec√≠fica da vaga",
        "Resultados quantificados que demonstrem compet√™ncias da vaga",
        "ADICIONE detalhes t√©cnicos espec√≠ficos da vaga se necess√°rio",
        "Conquistas que mostrem dom√≠nio das tecnologias da vaga"
      ]
    }
  ],
  "education": [
    "MANTENHA TODA educa√ß√£o real mas adapte projetos para serem relevantes"
  ],
  "certifications": [
    "MANTENHA todas certifica√ß√µes reais + ADICIONE certifica√ß√µes relevantes se o candidato provavelmente as teria"
  ],
  "projects": [
    "MANTENHA todos projetos reais mas adapte descri√ß√µes para usar tecnologias da vaga"
  ],
  "achievements": ["TODAS conquistas reais + conquistas relevantes para a vaga"],
  "activities": ["TODAS atividades reais + atividades que demonstrem interesse na √°rea da vaga"],
  "keywords": ["TODAS palavras-chave EXATAS extra√≠das da vaga"]
}`
      }
    ];

    let lastError: Error | null = null;

    // Tenta cada provider em sequ√™ncia
    for (const provider of this.providers) {
      try {
        // Verifica se a API key est√° configurada
        const apiKeyEnvVar = this.getApiKeyEnvVar(provider.name);
        if (!apiKeyEnvVar) {
          console.log(`‚ö†Ô∏è ${provider.name}: API key n√£o configurada, pulando...`);
          continue;
        }

        const response = await this.callProvider(provider, messages);
        
        // Tenta fazer parse do JSON
        try {
          const cleanResponse = this.cleanJsonResponse(response);
          const cvData: CVData = JSON.parse(cleanResponse);
          
          // Valida√ß√£o b√°sica
          if (this.validateCVData(cvData)) {
            console.log(`üéâ CV otimizado com sucesso usando ${provider.name}`);
            return cvData;
          } else {
            throw new Error('Dados do CV incompletos ap√≥s valida√ß√£o');
          }
          
        } catch (parseError) {
          console.error(`Erro ao fazer parse da resposta de ${provider.name}:`, parseError);
          lastError = parseError as Error;
          continue;
        }
        
      } catch (error) {
        console.error(`Falha em ${provider.name}:`, error);
        lastError = error as Error;
        continue;
      }
    }

    // Se chegou aqui, todos os providers falharam
    console.error('Todos os provedores de IA falharam');
    throw new Error('N√£o foi poss√≠vel conectar com os servi√ßos de IA. Verifique sua conex√£o com a internet e tente novamente.');
  }

  private static getApiKeyEnvVar(providerName: string): string | undefined {
    switch (providerName) {
      case 'HuggingFace':
        return import.meta.env.VITE_HUGGINGFACE_API_KEY;
      case 'Gemini':
        return import.meta.env.VITE_GEMINI_API_KEY;
      case 'OpenRouter':
        return import.meta.env.VITE_OPENROUTER_API_KEY;
      default:
        return undefined;
    }
  }

  private static cleanJsonResponse(response: string): string {
    // Remove poss√≠veis caracteres extras e foca no JSON
    let cleaned = response.trim();
    
    // Procura pelo in√≠cio e fim do JSON
    const startIndex = cleaned.indexOf('{');
    const lastBraceIndex = cleaned.lastIndexOf('}');
    
    if (startIndex !== -1 && lastBraceIndex !== -1 && lastBraceIndex > startIndex) {
      cleaned = cleaned.substring(startIndex, lastBraceIndex + 1);
    }
    
    return cleaned;
  }

  private static validateCVData(cvData: any): cvData is CVData {
    return (
      cvData &&
      typeof cvData.name === 'string' &&
      typeof cvData.email === 'string' &&
      typeof cvData.summary === 'string' &&
      Array.isArray(cvData.experience) &&
      Array.isArray(cvData.education) &&
      typeof cvData.skills === 'object'
    );
  }
}